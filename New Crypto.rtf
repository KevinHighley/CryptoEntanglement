{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\froman\fprq0\fcharset128 Liberation Mono{\*\falt Courier New};}{\f5\froman\fprq0\fcharset128 DejaVu Sans;}{\f6\froman\fprq0\fcharset128 Liberation Serif{\*\falt Times New Roman};}{\f7\fswiss\fprq0\fcharset128 Liberation Sans{\*\falt Arial};}{\f8\froman\fprq0\fcharset128 Ubuntu Mono;}{\f9\froman\fprq0\fcharset128 Courier 10 Pitch;}{\f10\froman\fprq0\fcharset128 Nimbus Sans L{\*\falt Arial};}{\f11\fnil\fprq0\fcharset128 Liberation Serif{\*\falt Times New Roman};}{\f12\fnil\fprq0\fcharset128 FreeSans;}{\f13\fnil\fprq2\fcharset0 FreeSans;}{\f14\fswiss\fprq0\fcharset128 FreeSans;}{\f15\fnil\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue128;\red192\green192\blue192;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057 Normal;}
{\s15\sbasedon0\snext16\ql\nowidctlpar\sb240\sa120\keepn\ltrpar\cf1\kerning1\dbch\af12\langfe2052\dbch\af13\afs28\alang1081\loch\f7\fs28\lang2057 Heading;}
{\s16\sbasedon0\snext16\sl288\slmult1\ql\nowidctlpar\sb0\sa140\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057 Text Body;}
{\s17\sbasedon16\snext17\sl288\slmult1\ql\nowidctlpar\sb0\sa140\ltrpar\cf1\kerning1\dbch\af12\langfe2052\dbch\af14\afs24\alang1081\loch\f6\fs24\lang2057 List;}
{\s18\sbasedon0\snext18\ql\nowidctlpar\sb120\sa120\noline\ltrpar\cf1\i\kerning1\dbch\af12\langfe2052\dbch\af14\afs24\alang1081\ai\loch\f6\fs24\lang2057 Caption;}
{\s19\sbasedon0\snext19\ql\nowidctlpar\noline\ltrpar\cf1\kerning1\dbch\af12\langfe2052\dbch\af14\afs24\alang1081\loch\f6\fs24\lang2057 Index;}
{\s20\sbasedon0\snext20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057 Preformatted Text;}
}{\info{\creatim\yr2016\mo4\dy6\hr10\min40}{\revtim\yr2016\mo4\dy7\hr19\min0}{\printim\yr2016\mo4\dy9\hr17\min38}{\comment LibreOffice}{\vern67241986}}\deftab709

{\*\pgdsctbl
{\pgdsc0\pgdscuse451\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Default Style;}}
\formshade{\*\pgdscno0}\paperh16838\paperw11906\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc{\cf1\afs36\rtlch \ltrch\loch\fs36\loch\f5
Encryption}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Keeping secrets has been important for thousands of years, modern communication systems and computers have given us new ways to store and exchange information, and new ways for the wrong people to read it.   Encryption is a tool to tackle such problems, but what is it, and as a programmer, how do I do it?  }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Conventional encryption is about securing communications.   A message is converted to a form that only the intended recipient can read.   Often this  depends on information that only the sender and recipient know,  used as a key to 'unlock' the message.   }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\i\ai\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
It is assumed that any intercepting party knows about the encrypting methods.    Obviously, if an enemy doesn't know a message exists they won't be looking for it.  Even if they catch a message, we hope they won't recognize it as such, or know how to read it.   The only safe assumption however is that the enemy knows everything they could possibly know.   Security through obscurity sometimes works, but you never know if someone even more obscure is watching you.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i\ai\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
Simple Systems}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i\ai\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
A message is a series of symbols, for our purposes a string of characters.   Their meaning can be disguised by re-arranging their order and/or by substituting for individual characters with other characters. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
For example let us take the message \uc2 \u8220\'81\'67What shall we do tonight?\u8221\'81\'68  A simple re-ordering is achieved by arranging the letters in an array horizontally, and reading them out vertically.  25 characters, so a 5x5 array.\uc1 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\loch\f8
W h a t\tab }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\loch\f8
s h a l l}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\f8
  }{\cf1\rtlch \ltrch\loch\loch\f8
w e   d}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\loch\f8
o   t o n}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\loch\f8
i g h t ?}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\loch\f5
Coded, the message becomes  \uc2 \u8220\'81\'67Ws oihhw gaaethtl ot ldn?\u8221\'81\'68\uc1 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Replacing each character with a letter from a certain distance further along in the alphabet (or for us the ascii code) gives a code reputedly used by Julius Caesar.   If the offset is +1 we get }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f8

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\f8
\uc2 \u8220\'81\'67\uc1 }{\cf1\rtlch \ltrch\loch\loch\f8
What shall we do tonight?\uc2 \u8221\'81\'68  becomes\uc1 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057{\cf1\rtlch \ltrch\loch\f8
\uc2 \u8220\'81\'67\uc1 }{\cf1\rtlch \ltrch\loch\loch\f8
Xibu!tibmm!xf!ep!upojhiu@\uc2 \u8221\'81\'68.\uc1 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f8

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
Both these approaches yield exciting looking messages, but would be easy to unravel. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
Both types were used in ancient times.  The Greeks supposedly spirally wrapped a strip of leather round a stick, and wrote along the stick.   The message could only be read if  wrapped around the same diameter stick.   This gives a version of the re-ordering code above.   The stick diameter key corresponding to the dimensions of the array.  In  Julius Caesar's code the key is how many letters to shift along.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs20\ai0\rtlch \ltrch\fs20\loch\f5
 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
I can see that ! Is probably space and @ a punctuation mark.   On a longer message, and with some idea about what the message might be about, and what language it is in analysing letter frequencies will soon reveal all.  A more elaborate character substitution system than to just shift n characters along would not help.   The commonest character in the output still represents the commonest character in the input.  }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
We can make the code look much more exotic by using strange fonts, Egyptian hieroglyphs or made up special symbols.   So long as each letter in our plain text is always represented by the same symbol it is relatively simple to break the code.   In normal English text \uc2 \u8220\'81\'67 \u8221\'81\'68 and \u8220\'81\'67e\u8221\'81\'68 occur much more often than \u8220\'81\'67x\u8221\'81\'68 and \u8220\'81\'67q\u8221\'81\'68.   Count the number of times each symbol in the encoded text appears, and replace each symbol with the letter that occurs with the most similar frequency in English (or whatever language you think the message is in).   This will often immediately give you something that is almost readable, needing only a few letter allocations to be swapped about.   This gets easier with larger messages, and messages in which you can guess that certain words or people's names are likely. \uc1 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
A less obviously structured re-ordering of the characters would be better, and we need a substitution system in which the same character might be represented by different characters each time it appears. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
Computers and keys}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
Those older systems had keys of only a few letters or digits, there are only 26 letters in the alphabet, and only a limited number of practical stick sizes.   In current terms they are 4 or 5 bit codes, they have only 2^4 or 2^5 possible keys.  Such small key encryption systems can be broken by a sufficiently powerful modern computer.    Simply run a version of the decrypting algorithm with every possible key.   We can devise systems with more complex keys, but while a human codebreaker might be daunted by a system that required thousands of tries to find the right key, computers thrive on big numbers.    WWII code crackers would have been delighted with the power of a modern laptop, but would have reminded you, if you\uc2 \u8217\'81\'66ve got this, what have the big boys got?   A coding system that would take, even with the world's top computers, years to break  seems secure enough, very little intelligence stays useful for more than months.   However \uc1 \u8211\'3f are you sure you know just how fast those top machines are?  Are you sure there is no easier back-door way to unpick your encryption, which could improve decryption rates by orders of magnitude?  }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
How big does a key need to be?   Current super computers are chasing 100 petaflops (10^17)  and there are about 10^8 seconds in three years.   A reasonably lucky code breaker might find the right value after trying 10% of all the possible values. Perhaps some secret, clever, dedicated code breaking system can test a key value in the time the machines we do know about take to do a floating point operation (note how fast colossus was compared with general purpose machines of the late 40s).   We need keys giving more than 10^26 possibilities, more still if we suspect there may be any cracks in the encryption method.   10^26 ~= 2^87.  Even with the more reasonable assumptions, that it might take 1000 operations to test a key, and that results are needed within a day, we still need a key with > 10^20 possibilities, that's about 2^67.   The argument about 64 bit versus 128 bit encryption becomes clear.   Even a perfect code system with no flaws and back doors might be breakable by brute force if it uses 64 bit or smaller keys.   For the brute force decoder, as the key size goes up the problem becomes selecting probable messages (e.g. ones with recognizable words in them) from the vast number of possibles generated.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
A large key makes brute force (try everything) approaches expensive in computer time and thus impractical. We need an algorithm that makes it hard work to test each key. We don't want the breaker to be able to reject a key after just a few characters, we want no output until they have decoded most of the message.  We also need to avoid anything that lets them home in on a solution.   Trying to find our way to a particular level on a smooth slope is much easier than trying to find a stone of  a particular weight from a pile of similar stones by weighing one at a time.  If we were trying to find the zeroes of a function it is much easier if the function has smooth derivatives, and much harder if it seems to be a random step function.  }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
One time pads}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
One way of defeating the frequency analysis attack is to use Julius Caesar's substitution method, but have a different offset for each character in the message.   The key is now a list of numbers the same size as the message, each number indicating the amount to shift the corresponding character in the message.   The large key size is a problem, it is too big for people to remember, and if written down and passed around it is possible for an enemy to learn of it.   Another weakness is that the same pattern is used for every message.  If many messages have the same format e.g. starting with the senders name and the date, the same pattern will appear at the start of each coded message, providing something for the code breaker to attack.   Adding a re-ordering step makes patterns harder to spot, but not impossible.  A solution is to change the list of offset numbers frequently, although this leads to problems of how you distribute the large and numerous keys.  If a new table of numbers is used for every message this becomes a 'one time pad' system, somewhat cumbersome, but completely secure so long as the particular table used has no pattern  and stays secret.   }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
The one time pad system was widely used, despite the problems of key distribution.   Many tables of numbers were prepared, all different and serial numbered.  A field agent would be issued with some.   When contacting base they would use a table to encode their message, and then destroy the sheet containing that table.   The only copy of that particular table, identified by it's serial number, now exists at base, so only they can decode the message. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
The Enigma}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
Another way of changing the coding for each character was enigma type machines.   They had a series of wheels, each of which generated a substitute for whichever letter you fed to it.  Several wheels in series providing a more elaborate pathway.   Pressing a key on the typewriter style keyboard connected through all the wheels, and lit a bulb to display a letter.   The clever bit was that the wheels were moved on after each letter had been pressed, generating a new sequence of connections, and a new coding for the next letter.   The key for this system involved knowing the wiring patterns of all the wheels, which wheel was in each slot in the machine, and where each wheel has been rotated to at the start of the message.  There were also jumpers that controlled other variables.   In all a fiendishly complicated device. The story of how these codes were broken at Bletchley park is well worth a read and visit if you don't already know it. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
Other Methods}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
There are other ways of sending secret messages.   Some are variations on the substitution and re-arrangement types.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
Public key encryption, important for much of web security, is a system where the key used to encrypt is different to the one needed to decrypt.   It depends upon finding mathematical operations which are easy to do in one direction but difficult to reverse.  For instance, finding the prime factors of very large numbers can be difficult,  multiplying together several large primes is fairly easy.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
Code systems where symbols stand for concepts rather than characters are hard to break.  The problems overlap with the those of trying to understand  dead languages.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
To be pedantic most of what we have been looking at should be referred to as ciphers rather than codes.   Ciphers tend to have a 1:1 relationship between plain text character counts and disguised text counts, codes can have complex ideas represented by short sets of symbols. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
The code talkers of WW2 and  the book code, as used in a Sherlock Holmes story, did not need a computer, nor do slang, jargon and the ever evolving languages of youth, designed to keep parents in the dark.   These I can ignore in the next section, on using a computer for encryption.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
Book code:  Message is sent as a series of number triads, each representing a word from a book selected by page:line:word.   If needed, number quads can represent individual letters.   The key here is the book to be used.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li1418\ri0\lin1418\rin0\fi0\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
Code talkers:  Messages were sent as conversations between members of a native American tribe in their own language.   There were only a few speakers of the language left, and it was not available in a written form, so there was little chance of an enemy understanding it.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
As for quantum methods, well, I just don't know how they work.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc\li0\ri0\lin0\rin0\fi0{\cf1\i0\afs36\ai0\rtlch \ltrch\loch\fs36\loch\f5
Programmers do it with a Computer }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li1418\ri0\lin1418\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f5
Fortunately for the code writer (if not for big brother) it is simple to implement, scrambling, one time pad, and enigma type codes on almost any computer.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li-709\ri0\lin-709\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f5
My programs frequently do the same thing to all the elements of an array.  All the arrays are the same size, 256 bytes.  To save writing the same code repeatedly}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa283{\cf2\alang1025\rtlch \ltrch\loch
\tab \tab }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
#define Ri for(i=0;i<=255;i++)}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
Table (aka wheel) of size 256, and contains one each of each possible value. Why? }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa283{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
I am assuming the enemy knows everything, so I might as well use sizes that are convenient for computing.  In assembler I used 8 bit characters, pointers, and arithmetic.  256 eliminates the need for range checking, an 8 bit pointer can't get out of a 256 array.  All different values reduces the key size from 256^256 ~= 10^616 to a mere 256!  ~= 10^506 - still a big number.   By keeping all the numbers and merely re-arranging each pass I hope to avoid a wheel ever collapsing to all zeros, or other problem pattern.   An all different 256 array can be used as a scrambling tool as well as a one time pad tool.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Characters are often stored as 8 bit values.   Those 8 bit values can be treated as numbers in the range 0-255.   Using 8 bit unsigned arithmetic, if I add numbers in the range 0-255 to the numbers representing each character in my message, I will get a new collection of numbers in the same range. With 8 bit arithmetic, overflows are discarded.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\tx1054\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f10
If the plain text is in an array }{\cf1\rtlch \ltrch\loch\loch\f5
\tab \tab }{\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f9
uint8_t a[256]}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f10
and our random numbers key in}{\cf1\rtlch \ltrch\loch\loch\f5
\tab }{\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f9
\tab uint8_t x[256]}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f9

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f10
then\tab }{\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f9
\tab \tab \tab \tab Ri a[i] += x[i];}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f5
provides the encryption step, a[] now contains the encrypted message.   a[] and x[] need to be unsigned char or uint8_t to get the right overflow behaviour.   That's it! unbreakable encryption in one statement.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
Part of the security problem is to ensure that the machines you are using are not already infested with some key grabber or screen shot program that records the plain text before you encrypt it.  This is easier to check with less software layers between you and the hardware.   The code examples were first imagined in assembler, to run on very minimal machines.   This was changed because A, My friends no longer use such machines, and B, few find assembler easy to read, and the point of writing the code was to illustrate an idea.   The current program in minimal C running on the console (stdin/stdout) should run on many machines.   I want you to modify and compile for yourself, at this level of security code, don't trust anything where you haven't seen and understood the source.   For better security . . am I paranoid, or is that windows 10 watching me?  Run your encrypt and decrypt programs on a small machine that is not connected to any network or other machines, and transfer the encrypted file via a memory stick to the machine that sends it.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\rtlch \ltrch\loch

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
If I later subtract the same numbers, I will get back my original character values, underflows are also discarded.  If all the numbers added had been the same we would have had Julius Caesar's code, but as the numbers added are all different, and nearly random (no patterns to find and exploit), we have a strong code.   The key is now a table of nearly random numbers the same size as the message.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li-709\ri0\lin-709\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li0\ri0\lin0\rin0\fi0{\cf1\rtlch \ltrch\loch\loch\f5
Decrypt is just }{\cf1\afs20\rtlch \ltrch\loch\fs20\loch\f9
\tab \tab \tab Ri a[i] -= x[i];}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\li709\ri0\lin709\rin0\fi0\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The random number table approach is good, but the table must change frequently. If we make our table of random numbers completely new for each message we have a 'one time pad' system.   If we were to move to a different place in the table after each character we have an enigma like system.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
We need random number tables. Assuming the random generator has been seeded, the following code generates one.}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf3\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch
uint8_t a,b,z;}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch
int i;}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\alang1025\rtlch \ltrch\loch

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch
Ri x[i] = i;                   // Fill x array with values 0 - 255}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch
for (i=0;i<2000;i++)           // Swap random pairs of values}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch
    }{\cf1\alang1025\rtlch \ltrch\loch
\{a = rand(); b = rand();   // 2000 times to give all possible}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch
     }{\cf1\alang1025\rtlch \ltrch\loch
z = x[a];                 // 8 bit numbers, but in a random}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch
     }{\cf1\alang1025\rtlch \ltrch\loch
x[a] = x[b];              // order. Like Eric Morecombe's music}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch
     }{\cf1\alang1025\rtlch \ltrch\loch
x[b] = z;                 // "All the right notes, but not }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch
    }{\cf1\alang1025\rtlch \ltrch\loch
\}                          // necessarily in the right order."}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0\cf1\i\alang1025\ai\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0{\cf1\i\alang1025\ai\rtlch \ltrch\loch\loch\f5
It might be better to restrict rand() to produce only numbers in the range 0-255, here it seems to work, presumably by taking only the bottom 8 bits.  There are probably many better ways, but it is important to be your own carpenter when making random number tables. The only way to read a one time pad system is to know the tables, if you copy some else's tables or their generating code that might just be discoverable.  It is also unwise to rely on the system supplied random number generator, some are flawed.   Using the random number indirectly as here may insulate you from some generator foibles. }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
With this sort of random number table containing one each of the numbers 0-255 an order scrambling routine is very simple to implement.}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li-709\ri0\lin-709\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
With x[] the random table, o[] the plain text, and a[] the scrambled text,}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
To scramble, }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\tab \tab \tab Ri a[i] = o[x[i]];}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0\cf1\alang1025\rtlch \ltrch\loch\loch\f9

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\tx963\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
and to unscramble again,}{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\tab Ri o[x[i]] = a[i];}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0\cf1\alang1025\rtlch \ltrch\loch\loch\f9

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li709\ri0\lin709\rin0\fi0\sb0\sa0\cf1\alang1025\rtlch \ltrch\loch\loch\f9

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
The tools we have so far would enable us to produce a secure email encrypting program.   Generate a few million random number tables, store them on your machine, copy  onto a flash drive or DVD and give it to the intended recipient. Convert your message to an 8 bit unsigned character string, add a random number table, then use the same table to scramble.   Send the encrypted array, and tell recipient which random table to use to decrypt it.}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0{\cf1\i\alang1025\ai\rtlch \ltrch\loch\loch\f5
Potential problem?}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
If we re use the random numbers, even if changed daily, a repeatedly sent message that was all one character, such as blank, would be converted to an offset version of the table.  That may not seem to be a problem, the enemy doesn't know that you have sent an image of today's pattern.   But, imagine something resting on a  keyboard generating twenty pages of white space, even a dumb cracker might notice twenty consecutive identical messages, and figure out what had happened.  Such mishaps have been the clue that cracks a code.}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
So far so good, but the receiver may fall into the wrong hands, and the enemy obtain the random number flash drive, and details of your encrypt/decrypt algorithm.}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
We can dispense with the flash drive by making our machines scramble the random number array after each message.   We need to do exactly the same scrambling at both transmitter and receiver.  This has the advantage that even if a machine is captured it can only decode the next message, the tables used for previous messages are gone.   The one thing that transmitter and receiver have in common is the message, so use that to scramble the table.  }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
Random table in x[] encrypted message in a[] temporary z, all uint8_t. }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
 }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
Ri \{z = x[i];                         }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
     }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
x[i] = x[a[i]];}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
     }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
x[a[i]] = z;}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
    }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\} }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\i\alang1025\ai\rtlch \ltrch\loch\loch\f9

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The same code is used at both ends after encrypting or decrypting a message.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\i\ai\rtlch \ltrch\loch\loch\f5
\tab }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The system now changes the random table every message.   A single stage provides fairly solid encryption, the system is behaving almost as a one time pad.  An attacker with access to the receiver, all the encoded and some decoded messages would still be able to work out the current settings, and, knowing the scramble algorithm,  'unzip' the whole chain of messages. The next stage makes that  more difficult.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5
It would be useful to re-introduce  small keys, something the user can remember, which stops an enemy immediately using a captured machine.   We also need to make the decrypt more clock cycle hungry so that a captured machine cannot be quickly put back into action with brute force discovered small keys.   To this end I now introduce multiple random number tables, and a more complicated encryption algorithm.  Our small keys select the order in which the tables are used, and where in each table we start. }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\qj\li0\ri0\lin0\rin0\fi0\sb0\sa0\cf1\afs24\alang1025\rtlch \ltrch\loch\fs24\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The main encryption stage uses ideas from the enigma code machine (that's why I start calling random number tables wheels). As a character is encoded by a wheel it also moves that wheel to a new position. The process is repeated 5 times with five different wheels.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
We now have 6 wheels, they are implemented as the arrays x[256][6] , and 6 keys, stored in array k[6], each holding a value 0-255.   The array w[6] represents the slots in our imaginary enigma machine, so w[n] contains the number of the wheel in slot n. k[n] contains the starting position for the wheel in slot n.  Slot 0 has already been used with the initial encode and scramble. We count along the slots with j and have 6 working arrays a[~][6].   The already partly encrypted message starts in a[~][0], and ends up in a[~][5].}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
for(j=1;j<=5;j++)                        // Main enigma loop                         }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
   }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\{k = key[j];\tab \tab \tab \tab \tab // Wheel to start position}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
    }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
Ri \{a[i][j] = a[i][j-1] + x[k][w[j]];// Value from wheel added}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
  }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
k = [a[i][j-1]][w[j]];\tab \tab // Wheel moved to new position }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li709\ri0\lin709\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
 }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\} \tab \tab \tab \tab \tab \tab // according to character just read}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
   }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\}   }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Finally the code wheels are scrambled using the intermediate stages of the above encryption, (which being ephemeral are not available to a code breaker), to control the scramble.  Temporary swap value z is again uint8_t.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
for(j=0;j<=5;j++)                                              }
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
   }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\{Ri \{z = x[i][w[j]];}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
        }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
x[i][w[j]] = x[a[i][j]][w[j]];}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
        }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
x[a[i][j]][w[j]] = z;}
\par \pard\plain \s20\ql\nowidctlpar\sb0\sa0\ltrpar\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs20\alang1081\loch\f4\fs20\lang2057\li0\ri0\lin0\rin0\fi0\sb0\sa0{\cf1\alang1025\rtlch \ltrch\loch\f9
   }{\cf1\alang1025\rtlch \ltrch\loch\loch\f9
\}   \}}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The main encrypt loop and the code wheel scrambling are separate here to make it easier to see what is happening.   They could be combined into one loop to reduce memory use.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The decrypt routines are almost a mirror image of the encrypt.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\i\ai\rtlch \ltrch\loch\f5
 }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0{\cf1\i\afs20\ai\rtlch \ltrch\loch\fs20\loch\f5
I notice that the encoded message looks very different to the plain text \u8211\'3f lots of unprintable characters.   If messages are mostly printable characters then perhaps \tab we should convert the encoded text to mainly printables.   We will have to do that  any way in order to use some communication channels.   Or perhaps a first pass which assigns several of the 0-255 symbols to 'e' and 'space' and fewer to 'q' to  make messages look more like noise across the whole 0-255.   Anything which gives a breaker program less of a entry point is to be encouraged.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\li709\ri0\lin709\rin0\fi0\cf1\i\ai\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5
The demonstration program, available from \{_______________________\} is deliberately minimal, I want it to run on almost any machine with a C compiler.   Because I rely on 8 bit unsigned arithmetic, be careful if you change anything, not to mix uint8_t values with int counters.   The 8bit variables get promoted to 16 or 32, and 'interesting' things happen.   The demo uses two sets of x[] arrays, xs[] are the arrays on the source machine, xd[] on the destination.   I have a more elaborate version of the demo written using Qt widgets and C++.   It works on my Linux setup, but I have not yet ported it to Apple, Windows and Android, though this is supposed to be straight forward with Qt.   This will probably have been done by the time the article sees print \u8211\'3f although I am being distracted by the classic travelling salesman problem at the moment.   }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\i0\ai0\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qc{\cf1\afs36\rtlch \ltrch\loch\fs36\loch\f5
Conclusion}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
Secure communication between devices can be achieved by the one time pad system.   In the past this was restricted by the need to distribute coding pads with suitable sets  of random number tables, more data than all the messages to be sent put together.    The current price of memory sticks makes 16GB of random number tables generated, and physically passed between stations practical.   No wonder the authorities say they only want to store information about messages, not content.  The content of e-mails is potentially pretty secure anyway.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
I suggest an alternative approach which doesn't need big random number tables. Set up a few random number tables, matched on transmitter and receiver, and mutate them as part of the process of sending and receiving each message keeping Tx and Rx in step. This also has the effect of making the receiving machine capable of decoding only the current message, even with the right user keys.   A captured machine cannot decode past or future messages. }
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\cf1\rtlch \ltrch\loch\loch\f5

\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj{\cf1\rtlch \ltrch\loch\loch\f5
The old assumption was that the enemy has access to all message traffic, but not to either end.   A safer assumption is that either end may be compromised at any time, and to restrict potential damage in that event as much as possible.}
\par \pard\plain \s0\ql\nowidctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf1\kerning1\dbch\af11\langfe2052\dbch\af15\afs24\alang1081\loch\f6\fs24\lang2057\qj\rtlch \ltrch\loch

\par }